{"title":"leetcode_哈希表","date":"2026-02-09T14:10:15.000Z","source":"_posts/leetcode-哈希表.md","raw":"---\ntitle: leetcode_哈希表\ndate: 2026-02-09 22:10:15\ntags:\n---\n# 代码随想录——哈希表\n\n#### 哈希表应用场景：判断某个元素在一个集合里是否出现过\n\n### 242.有效的字母异位词\n\n给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的 字母异位词。\n#### 思路：\n\n使用一个数组record来存储每个字母的频率。可以不需要ascii码很巧妙的用charat-‘a’的方法来储存每个字母的频率！\n\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        int[] record = new int[26];\n        for(int i=0;i<s.length();i++){\n            record[s.charAt(i)-'a']++;\n        }\n        for(int j=0;j<t.length();j++){\n            record[t.charAt(j)-'a']--;\n        }\n        for (int count: record) {\n            if(count!=0){\n                return false;\n            }  \n        }\n        return true;\n    }\n}\n```\n\n### 349.两个数组的交集\n\n给定两个数组 `nums1` 和 `nums2` ，返回 *它们的 交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。\n\n#### 思路：\n\n把一个数组里的数字存在hashset1里，然后再把另一个数组里的数字拿出来在哈希表1里查找，把重复的放入第二个哈希表reset，因为哈希表可以自动去重，因此建立两个哈希表\n\n```java\nimport java.util.HashSet;\nimport java.util.Set;\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        if(nums1 == null ||nums1.length==0 || nums2 == null ||nums2.length==0){\n        return new int[0];\n        }\n    Set<Integer>set1 = new HashSet<>();\n    Set<Integer>reSet = new HashSet<>();\n    for(int i: nums1){\n        set1.add(i);\n    }\n    for(int i: nums2){\n        if(set1.contains(i)){\n            reSet.add(i);\n        }\n    }\n    return reSet.stream().mapToInt(Integer::intValue).toArray();\n}\n}\n```\n\n### 1.两数之和\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n\n你可以按任意顺序返回答案\n\n#### 思路：\n\n使用HashMap存储**遍历过的数字**，key为数字，value为下标，然后查找map里是否有target-nums[i]这个数字，如果有的话即为可与num[i]共同凑成target的一对数字，如果没有则把遍历过的存储进map进行下一个查找\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] res = new int[2];\n        if(nums == null || nums.length == 0){\n            return res;\n        }\n        Map<Integer,Integer>map = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            int temp = target-nums[i];\n            if(map.containsKey(temp)){\n                res[1]=i;\n                res[0]=map.get(temp);\n                break;\n            }\n            map.put(nums[i],i);\n        }\n        return res;\n    }\n}\n```\n\n### 49.字母异位词分组\n\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n\n\n#### 思路：\n\n字母异位词的排序都是相同的，所以可以使用一个HashMap来储存排序后的为key，value为原始的string，最后返回value。\n\n```java\npublic List<List<String>> groupAnagrams(String[] strs) {\n    // 1. 创建一个哈希表：key 是排序后的字符串，value 是该组的所有原字符串\n    Map<String, List<String>> map = new HashMap<>();\n    \n    // 2. 遍历每个字符串\n    for (String str : strs) {\n        // 3. 将字符串转为字符数组，方便排序\n        char[] array = str.toCharArray();\n        \n        // 4. 对字符数组排序（这是关键！）\n        Arrays.sort(array);\n        \n        // 5. 把排序后的字符数组转回字符串，作为“键”\n        String key = new String(array);\n        \n        // 6. 从 map 中获取当前 key 对应的列表（如果没有，就新建一个空列表）\n        List<String> list = map.getOrDefault(key, new ArrayList<>());\n        \n        // 7. 把当前原始字符串加入这个列表\n        list.add(str);\n     \n        // 8. 把更新后的列表放回 map\n        map.put(key, list);\n    }\n    \n    // 9. 返回 map 中所有的 value（即所有分组）\n    return new ArrayList<>(map.values());\n}\n```\n\n","slug":"leetcode-哈希表","published":true,"updated":"2026-02-09T14:20:20.200Z","_id":"cuid9PBWLabR49It7Do_1Rfmu","comments":true,"layout":"post","photos":[],"html":"<h1 id=\"代码随想录——哈希表\"><a href=\"#代码随想录——哈希表\" class=\"headerlink\" title=\"代码随想录——哈希表\"></a>代码随想录——哈希表</h1><h4 id=\"哈希表应用场景：判断某个元素在一个集合里是否出现过\"><a href=\"#哈希表应用场景：判断某个元素在一个集合里是否出现过\" class=\"headerlink\" title=\"哈希表应用场景：判断某个元素在一个集合里是否出现过\"></a>哈希表应用场景：判断某个元素在一个集合里是否出现过</h4><h3 id=\"242-有效的字母异位词\"><a href=\"#242-有效的字母异位词\" class=\"headerlink\" title=\"242.有效的字母异位词\"></a>242.有效的字母异位词</h3><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的 字母异位词。</p>\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>使用一个数组record来存储每个字母的频率。可以不需要ascii码很巧妙的用charat-‘a’的方法来储存每个字母的频率！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isAnagram</span><span class=\"params\">(String s, String t)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] record = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.length();i++)&#123;</span><br><span class=\"line\">            record[s.charAt(i)-<span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;t.length();j++)&#123;</span><br><span class=\"line\">            record[t.charAt(j)-<span class=\"string\">&#x27;a&#x27;</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> count: record) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(count!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"349-两个数组的交集\"><a href=\"#349-两个数组的交集\" class=\"headerlink\" title=\"349.两个数组的交集\"></a>349.两个数组的交集</h3><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的 交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>\n<h4 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>把一个数组里的数字存在hashset1里，然后再把另一个数组里的数字拿出来在哈希表1里查找，把重复的放入第二个哈希表reset，因为哈希表可以自动去重，因此建立两个哈希表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] intersection(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums1 == <span class=\"literal\">null</span> ||nums1.length==<span class=\"number\">0</span> || nums2 == <span class=\"literal\">null</span> ||nums2.length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    Set&lt;Integer&gt;set1 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">    Set&lt;Integer&gt;reSet = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i: nums1)&#123;</span><br><span class=\"line\">        set1.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i: nums2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(set1.contains(i))&#123;</span><br><span class=\"line\">            reSet.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reSet.stream().mapToInt(Integer::intValue).toArray();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>\n<p>你可以按任意顺序返回答案</p>\n<h4 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>使用HashMap存储<strong>遍历过的数字</strong>，key为数字，value为下标，然后查找map里是否有target-nums[i]这个数字，如果有的话即为可与num[i]共同凑成target的一对数字，如果没有则把遍历过的存储进map进行下一个查找</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] twoSum(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Map&lt;Integer,Integer&gt;map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> target-nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(temp))&#123;</span><br><span class=\"line\">                res[<span class=\"number\">1</span>]=i;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>]=map.get(temp);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(nums[i],i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"49-字母异位词分组\"><a href=\"#49-字母异位词分组\" class=\"headerlink\" title=\"49.字母异位词分组\"></a>49.字母异位词分组</h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>\n<h4 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>字母异位词的排序都是相同的，所以可以使用一个HashMap来储存排序后的为key，value为原始的string，最后返回value。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; <span class=\"title function_\">groupAnagrams</span><span class=\"params\">(String[] strs)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 创建一个哈希表：key 是排序后的字符串，value 是该组的所有原字符串</span></span><br><span class=\"line\">    Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 遍历每个字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String str : strs) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 将字符串转为字符数组，方便排序</span></span><br><span class=\"line\">        <span class=\"type\">char</span>[] array = str.toCharArray();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 4. 对字符数组排序（这是关键！）</span></span><br><span class=\"line\">        Arrays.sort(array);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 5. 把排序后的字符数组转回字符串，作为“键”</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(array);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 6. 从 map 中获取当前 key 对应的列表（如果没有，就新建一个空列表）</span></span><br><span class=\"line\">        List&lt;String&gt; list = map.getOrDefault(key, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 7. 把当前原始字符串加入这个列表</span></span><br><span class=\"line\">        list.add(str);</span><br><span class=\"line\">     </span><br><span class=\"line\">        <span class=\"comment\">// 8. 把更新后的列表放回 map</span></span><br><span class=\"line\">        map.put(key, list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 9. 返回 map 中所有的 value（即所有分组）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(map.values());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"代码随想录——哈希表\"><a href=\"#代码随想录——哈希表\" class=\"headerlink\" title=\"代码随想录——哈希表\"></a>代码随想录——哈希表</h1><h4 id=\"哈希表应用场景：判断某个元素在一个集合里是否出现过\"><a href=\"#哈希表应用场景：判断某个元素在一个集合里是否出现过\" class=\"headerlink\" title=\"哈希表应用场景：判断某个元素在一个集合里是否出现过\"></a>哈希表应用场景：判断某个元素在一个集合里是否出现过</h4><h3 id=\"242-有效的字母异位词\"><a href=\"#242-有效的字母异位词\" class=\"headerlink\" title=\"242.有效的字母异位词\"></a>242.有效的字母异位词</h3><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的 字母异位词。</p>\n<h4 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>使用一个数组record来存储每个字母的频率。可以不需要ascii码很巧妙的用charat-‘a’的方法来储存每个字母的频率！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isAnagram</span><span class=\"params\">(String s, String t)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] record = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s.length();i++)&#123;</span><br><span class=\"line\">            record[s.charAt(i)-<span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;t.length();j++)&#123;</span><br><span class=\"line\">            record[t.charAt(j)-<span class=\"string\">&#x27;a&#x27;</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> count: record) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(count!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"349-两个数组的交集\"><a href=\"#349-两个数组的交集\" class=\"headerlink\" title=\"349.两个数组的交集\"></a>349.两个数组的交集</h3><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的 交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>\n<h4 id=\"思路：-1\"><a href=\"#思路：-1\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>把一个数组里的数字存在hashset1里，然后再把另一个数组里的数字拿出来在哈希表1里查找，把重复的放入第二个哈希表reset，因为哈希表可以自动去重，因此建立两个哈希表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] intersection(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums1 == <span class=\"literal\">null</span> ||nums1.length==<span class=\"number\">0</span> || nums2 == <span class=\"literal\">null</span> ||nums2.length==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    Set&lt;Integer&gt;set1 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">    Set&lt;Integer&gt;reSet = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i: nums1)&#123;</span><br><span class=\"line\">        set1.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i: nums2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(set1.contains(i))&#123;</span><br><span class=\"line\">            reSet.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reSet.stream().mapToInt(Integer::intValue).toArray();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1.两数之和\"></a>1.两数之和</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p>\n<p>你可以按任意顺序返回答案</p>\n<h4 id=\"思路：-2\"><a href=\"#思路：-2\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>使用HashMap存储<strong>遍历过的数字</strong>，key为数字，value为下标，然后查找map里是否有target-nums[i]这个数字，如果有的话即为可与num[i]共同凑成target的一对数字，如果没有则把遍历过的存储进map进行下一个查找</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] twoSum(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Map&lt;Integer,Integer&gt;map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> target-nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(temp))&#123;</span><br><span class=\"line\">                res[<span class=\"number\">1</span>]=i;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>]=map.get(temp);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(nums[i],i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"49-字母异位词分组\"><a href=\"#49-字母异位词分组\" class=\"headerlink\" title=\"49.字母异位词分组\"></a>49.字母异位词分组</h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>\n<h4 id=\"思路：-3\"><a href=\"#思路：-3\" class=\"headerlink\" title=\"思路：\"></a>思路：</h4><p>字母异位词的排序都是相同的，所以可以使用一个HashMap来储存排序后的为key，value为原始的string，最后返回value。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; <span class=\"title function_\">groupAnagrams</span><span class=\"params\">(String[] strs)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 创建一个哈希表：key 是排序后的字符串，value 是该组的所有原字符串</span></span><br><span class=\"line\">    Map&lt;String, List&lt;String&gt;&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 遍历每个字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String str : strs) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 将字符串转为字符数组，方便排序</span></span><br><span class=\"line\">        <span class=\"type\">char</span>[] array = str.toCharArray();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 4. 对字符数组排序（这是关键！）</span></span><br><span class=\"line\">        Arrays.sort(array);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 5. 把排序后的字符数组转回字符串，作为“键”</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(array);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 6. 从 map 中获取当前 key 对应的列表（如果没有，就新建一个空列表）</span></span><br><span class=\"line\">        List&lt;String&gt; list = map.getOrDefault(key, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;());</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 7. 把当前原始字符串加入这个列表</span></span><br><span class=\"line\">        list.add(str);</span><br><span class=\"line\">     </span><br><span class=\"line\">        <span class=\"comment\">// 8. 把更新后的列表放回 map</span></span><br><span class=\"line\">        map.put(key, list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 9. 返回 map 中所有的 value（即所有分组）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(map.values());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","path":"2026/02/09/leetcode-哈希表/","permalink":"https://jennyliu1114.github.io/2026/02/09/leetcode-%E5%93%88%E5%B8%8C%E8%A1%A8/","tags":[],"categories":[],"prev":{"title":"【JAVA学习】第一天","date":"2026-02-09T14:21:45.000Z","slug":"【JAVA学习】第一天","published":true,"updated":"2026-02-09T14:22:40.933Z","_id":"cuidOlTmq31i3nowksce32IcY","layout":"post","photos":[],"excerpt":"","path":"2026/02/09/【JAVA学习】第一天/","permalink":"https://jennyliu1114.github.io/2026/02/09/%E3%80%90JAVA%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AC%AC%E4%B8%80%E5%A4%A9/","__post":true},"next":{"title":"leetcode_链表","date":"2026-02-09T14:09:59.000Z","slug":"leetcode-链表","published":true,"updated":"2026-02-09T14:20:07.925Z","_id":"cuid8BHq41K_NAAYYkZC4-4vC","layout":"post","photos":[],"excerpt":"","path":"2026/02/09/leetcode-链表/","permalink":"https://jennyliu1114.github.io/2026/02/09/leetcode-%E9%93%BE%E8%A1%A8/","__post":true},"__post":true}