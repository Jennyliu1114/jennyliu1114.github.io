{"pages":[{"title":"éšç¬”","text":"","link":"/%E9%9A%8F%E7%AC%94/index.html"},{"title":"ä¸ªäººä¸»é¡µ","text":"ğŸ“ æ•™è‚²èƒŒæ™¯ åŒ—äº¬é‚®ç”µå¤§å­¦ Â· äººå·¥æ™ºèƒ½å­¦é™¢ç¡•å£« Â· æ¨¡å¼è¯†åˆ«å®éªŒå®¤ï¼ˆå¤šæ¨¡æ€æ–¹å‘ï¼‰2025.09 â€“ è‡³ä»Š åŒ—äº¬é‚®ç”µå¤§å­¦ Â· å›½é™…å­¦é™¢å­¦å£« Â· ç”µä¿¡å·¥ç¨‹åŠç®¡ç†ä¸“ä¸š2021.09 â€“ 2025.06 ğŸ”¬ ç§‘ç ”ä¸è®ºæ–‡ğŸ“„ ã€ŠA Proposal-Free Query-Guided Network for Grounded Multimodal Named Entity Recognitionã€‹ç¬¬ä¸€ä½œè€…ï½œæŠ•ç¨¿è‡³ ICME 2026 (CCF-B) æå‡ºé¦–ä¸ªæ— éœ€å€™é€‰åŒºåŸŸçš„ç«¯åˆ°ç«¯ GMNER æ¡†æ¶ï¼Œé€šè¿‡æ–‡æœ¬å¼•å¯¼çš„å¯å­¦ä¹ æŸ¥è¯¢æœºåˆ¶ï¼Œå®ç°å‘½åå®ä½“ä¸å›¾åƒåŒºåŸŸçš„ç»†ç²’åº¦ç›´æ¥å¯¹é½ã€‚ è®¾è®¡ä¸‰å¤§æ ¸å¿ƒæ¨¡å—ï¼šMulti-View Query Attention (MQA)ã€Hierarchical Vision-Language Alignment (HVLA) ä¸ Multimodal Query Decoding (MQD)ï¼Œæ˜¾è‘—å¢å¼ºè·¨æ¨¡æ€äº¤äº’ä¸ä¸Šä¸‹æ–‡æ„ŸçŸ¥èƒ½åŠ›ã€‚ ğŸ“„ ã€ŠåŸºäºè‡ªé€‚åº”PIDçš„æ™ºèƒ½çŒæº‰é‡æ ·æœ¬é‡‡é›†ä¸æ ‡æ³¨æ–¹æ³•ã€‹ç¬¬ä¸€ä½œè€…ï½œç¬¬44å±Šä¸­å›½æ§åˆ¶ä¼šè®® (CCC 2025) ä¾æ‰˜ç•ªèŒ„æ™ºèƒ½æ°´è‚¥å†³ç­–é¡¹ç›®ï¼Œè®¾è®¡åŸºäºè‡ªé€‚åº” PID çš„è‡ªåŠ¨é‡‡æ ·ä¸æ ‡æ³¨æµç¨‹ã€‚ ä»¥æ¤ç‰©æ’æ°´é‡ä¸ºåé¦ˆä¿¡å·ï¼Œé—­ç¯æ§åˆ¶çŒæº‰æ—¶é•¿å¹¶è‡ªåŠ¨ç”Ÿæˆé«˜è´¨é‡æ ‡ç­¾ï¼Œå¤§å¹…é™ä½äººå·¥æ ‡æ³¨æˆæœ¬ã€‚ æ”¯æŒä¸“å®¶å‘¨æœŸæ€§ç¡®è®¤ä¸æ‰‹åŠ¨è¦†å†™ï¼Œä¿éšœæ•°æ®å¯é æ€§ã€‚ ğŸ’» é¡¹ç›®ç»å†ğŸ‘ï¸ æ•æ„Ÿäººç‰©äººè„¸è¯†åˆ«ç³»ç»Ÿï½œé¡¹ç›®è´Ÿè´£äººï½œ2024.11 â€“ 2025.05 é’ˆå¯¹å°è„¸/ä¾§è„¸æ£€æµ‹ç‡ä½çš„é—®é¢˜ï¼Œå¼•å…¥ RetinaFace æ›¿ä»£ dlibï¼Œæ˜¾è‘—æå‡äººè„¸æ£€æµ‹å¬å›ç‡ã€‚ é‡æ„ç«¯åˆ°ç«¯è¯†åˆ«æµç¨‹ï¼Œé›†æˆ RetinaFace + InceptionResNetV1ï¼Œå®Œæˆé«˜æ•ˆç‰¹å¾æå–ä¸åŒ¹é… pipeline ä¼˜åŒ–ã€‚ ğŸ† è£èª‰ä¸å¥–é¡¹ å›½å®¶å¥–å­¦é‡‘ï¼ˆ2024ï¼‰ åŒ—äº¬å¸‚ä¼˜ç§€æ¯•ä¸šç”Ÿï¼ˆ2025ï¼‰ åŒ—äº¬é‚®ç”µå¤§å­¦ä¼˜ç§€å­¦ç”Ÿå¹²éƒ¨ï¼ˆ2024ï¼‰ åŒ—äº¬é‚®ç”µå¤§å­¦ä¸‰å¥½å­¦ç”Ÿ &amp; æ ¡äºŒç­‰å¥–å­¦é‡‘ï¼ˆ2023ï¼‰ ç¾å›½å¤§å­¦ç”Ÿæ•°å­¦å»ºæ¨¡ç«èµ› H å¥–ï¼ˆ2024ï¼‰","link":"/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2026/02/06/hello-world/"},{"title":"leetcode_å“ˆå¸Œè¡¨","text":"ä»£ç éšæƒ³å½•â€”â€”å“ˆå¸Œè¡¨å“ˆå¸Œè¡¨åº”ç”¨åœºæ™¯ï¼šåˆ¤æ–­æŸä¸ªå…ƒç´ åœ¨ä¸€ä¸ªé›†åˆé‡Œæ˜¯å¦å‡ºç°è¿‡242.æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ t ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­ t æ˜¯å¦æ˜¯ s çš„ å­—æ¯å¼‚ä½è¯ã€‚ æ€è·¯ï¼šä½¿ç”¨ä¸€ä¸ªæ•°ç»„recordæ¥å­˜å‚¨æ¯ä¸ªå­—æ¯çš„é¢‘ç‡ã€‚å¯ä»¥ä¸éœ€è¦asciiç å¾ˆå·§å¦™çš„ç”¨charat-â€˜aâ€™çš„æ–¹æ³•æ¥å‚¨å­˜æ¯ä¸ªå­—æ¯çš„é¢‘ç‡ï¼ 1234567891011121314151617class Solution { public boolean isAnagram(String s, String t) { int[] record = new int[26]; for(int i=0;i&lt;s.length();i++){ record[s.charAt(i)-'a']++; } for(int j=0;j&lt;t.length();j++){ record[t.charAt(j)-'a']--; } for (int count: record) { if(count!=0){ return false; } } return true; }} 349.ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†ç»™å®šä¸¤ä¸ªæ•°ç»„ nums1 å’Œ nums2 ï¼Œè¿”å› å®ƒä»¬çš„ äº¤é›† ã€‚è¾“å‡ºç»“æœä¸­çš„æ¯ä¸ªå…ƒç´ ä¸€å®šæ˜¯ å”¯ä¸€ çš„ã€‚æˆ‘ä»¬å¯ä»¥ ä¸è€ƒè™‘è¾“å‡ºç»“æœçš„é¡ºåº ã€‚ æ€è·¯ï¼šæŠŠä¸€ä¸ªæ•°ç»„é‡Œçš„æ•°å­—å­˜åœ¨hashset1é‡Œï¼Œç„¶åå†æŠŠå¦ä¸€ä¸ªæ•°ç»„é‡Œçš„æ•°å­—æ‹¿å‡ºæ¥åœ¨å“ˆå¸Œè¡¨1é‡ŒæŸ¥æ‰¾ï¼ŒæŠŠé‡å¤çš„æ”¾å…¥ç¬¬äºŒä¸ªå“ˆå¸Œè¡¨resetï¼Œå› ä¸ºå“ˆå¸Œè¡¨å¯ä»¥è‡ªåŠ¨å»é‡ï¼Œå› æ­¤å»ºç«‹ä¸¤ä¸ªå“ˆå¸Œè¡¨ 1234567891011121314151617181920import java.util.HashSet;import java.util.Set;class Solution { public int[] intersection(int[] nums1, int[] nums2) { if(nums1 == null ||nums1.length==0 || nums2 == null ||nums2.length==0){ return new int[0]; } Set&lt;Integer&gt;set1 = new HashSet&lt;&gt;(); Set&lt;Integer&gt;reSet = new HashSet&lt;&gt;(); for(int i: nums1){ set1.add(i); } for(int i: nums2){ if(set1.contains(i)){ reSet.add(i); } } return reSet.stream().mapToInt(Integer::intValue).toArray();}} 1.ä¸¤æ•°ä¹‹å’Œç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º å’Œä¸ºç›®æ ‡å€¼ target çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚ ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆï¼Œå¹¶ä¸”ä½ ä¸èƒ½ä½¿ç”¨ä¸¤æ¬¡ç›¸åŒçš„å…ƒç´ ã€‚ ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆ æ€è·¯ï¼šä½¿ç”¨HashMapå­˜å‚¨éå†è¿‡çš„æ•°å­—ï¼Œkeyä¸ºæ•°å­—ï¼Œvalueä¸ºä¸‹æ ‡ï¼Œç„¶åæŸ¥æ‰¾mapé‡Œæ˜¯å¦æœ‰target-nums[i]è¿™ä¸ªæ•°å­—ï¼Œå¦‚æœæœ‰çš„è¯å³ä¸ºå¯ä¸num[i]å…±åŒå‡‘æˆtargetçš„ä¸€å¯¹æ•°å­—ï¼Œå¦‚æœæ²¡æœ‰åˆ™æŠŠéå†è¿‡çš„å­˜å‚¨è¿›mapè¿›è¡Œä¸‹ä¸€ä¸ªæŸ¥æ‰¾ 12345678910111213141516171819class Solution { public int[] twoSum(int[] nums, int target) { int[] res = new int[2]; if(nums == null || nums.length == 0){ return res; } Map&lt;Integer,Integer&gt;map = new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++){ int temp = target-nums[i]; if(map.containsKey(temp)){ res[1]=i; res[0]=map.get(temp); break; } map.put(nums[i],i); } return res; }} 49.å­—æ¯å¼‚ä½è¯åˆ†ç»„ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œè¯·ä½ å°† å­—æ¯å¼‚ä½è¯ ç»„åˆåœ¨ä¸€èµ·ã€‚å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç»“æœåˆ—è¡¨ã€‚ æ€è·¯ï¼šå­—æ¯å¼‚ä½è¯çš„æ’åºéƒ½æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨ä¸€ä¸ªHashMapæ¥å‚¨å­˜æ’åºåçš„ä¸ºkeyï¼Œvalueä¸ºåŸå§‹çš„stringï¼Œæœ€åè¿”å›valueã€‚ 12345678910111213141516171819202122232425262728public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { // 1. åˆ›å»ºä¸€ä¸ªå“ˆå¸Œè¡¨ï¼škey æ˜¯æ’åºåçš„å­—ç¬¦ä¸²ï¼Œvalue æ˜¯è¯¥ç»„çš„æ‰€æœ‰åŸå­—ç¬¦ä¸² Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); // 2. éå†æ¯ä¸ªå­—ç¬¦ä¸² for (String str : strs) { // 3. å°†å­—ç¬¦ä¸²è½¬ä¸ºå­—ç¬¦æ•°ç»„ï¼Œæ–¹ä¾¿æ’åº char[] array = str.toCharArray(); // 4. å¯¹å­—ç¬¦æ•°ç»„æ’åºï¼ˆè¿™æ˜¯å…³é”®ï¼ï¼‰ Arrays.sort(array); // 5. æŠŠæ’åºåçš„å­—ç¬¦æ•°ç»„è½¬å›å­—ç¬¦ä¸²ï¼Œä½œä¸ºâ€œé”®â€ String key = new String(array); // 6. ä» map ä¸­è·å–å½“å‰ key å¯¹åº”çš„åˆ—è¡¨ï¼ˆå¦‚æœæ²¡æœ‰ï¼Œå°±æ–°å»ºä¸€ä¸ªç©ºåˆ—è¡¨ï¼‰ List&lt;String&gt; list = map.getOrDefault(key, new ArrayList&lt;&gt;()); // 7. æŠŠå½“å‰åŸå§‹å­—ç¬¦ä¸²åŠ å…¥è¿™ä¸ªåˆ—è¡¨ list.add(str); // 8. æŠŠæ›´æ–°åçš„åˆ—è¡¨æ”¾å› map map.put(key, list); } // 9. è¿”å› map ä¸­æ‰€æœ‰çš„ valueï¼ˆå³æ‰€æœ‰åˆ†ç»„ï¼‰ return new ArrayList&lt;&gt;(map.values());}","link":"/2026/02/09/leetcode-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"title":"leetcode_é“¾è¡¨","text":"ä»£ç éšæƒ³å½•â€”â€”é“¾è¡¨203. ç§»é™¤é“¾è¡¨å…ƒç´ ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head å’Œä¸€ä¸ªæ•´æ•° val ï¼Œè¯·ä½ åˆ é™¤é“¾è¡¨ä¸­æ‰€æœ‰æ»¡è¶³ Node.val == val çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å› æ–°çš„å¤´èŠ‚ç‚¹ ã€‚ æ€è·¯ï¼šè®¾ç½®ä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹dummyæŒ‡å‘ç°åœ¨çš„å¤´èŠ‚ç‚¹headï¼Œè¿™æ ·å°±ä¸ç”¨å•ç‹¬è€ƒè™‘åˆ é™¤å¤´èŠ‚ç‚¹çš„æƒ…å†µäº†ã€‚ç„¶ånewä¸€ä¸ªæŒ‡é’ˆcurï¼Œåˆ¤æ–­curæ˜¯å¦ç­‰äºè¦åˆ é™¤çš„valï¼Œå¦‚æœç­‰äºçš„è¯è¦è®©cur.next = cur.next.next (æ³¨æ„æ˜¯cur.nextè€Œä¸æ˜¯curï¼å› ä¸ºè¦æ”¹å˜çš„æ˜¯curä¸‹ä¸€ä¸ªæŒ‡å‘çš„å†…å®¹ï¼) æœ€åè¿”å›çš„æ˜¯dummy.nextï¼ 12345678910111213141516class Solution { public ListNode removeElements(ListNode head, int val) { ListNode dummy = new ListNode(); dummy.next = head; ListNode cur = dummy; while(cur.next != null){ if(cur.next.val == val){ cur.next = cur.next.next; } else{ cur = cur.next; } } return dummy.next; }} 707.è®¾è®¡é“¾è¡¨ä½ å¯ä»¥é€‰æ‹©ä½¿ç”¨å•é“¾è¡¨æˆ–è€…åŒé“¾è¡¨ï¼Œè®¾è®¡å¹¶å®ç°è‡ªå·±çš„é“¾è¡¨ã€‚ å•é“¾è¡¨ä¸­çš„èŠ‚ç‚¹åº”è¯¥å…·å¤‡ä¸¤ä¸ªå±æ€§ï¼šval å’Œ next ã€‚val æ˜¯å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œnext æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ/å¼•ç”¨ã€‚ å¦‚æœæ˜¯åŒå‘é“¾è¡¨ï¼Œåˆ™è¿˜éœ€è¦å±æ€§ prev ä»¥æŒ‡ç¤ºé“¾è¡¨ä¸­çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ã€‚å‡è®¾é“¾è¡¨ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ä¸‹æ ‡ä» 0 å¼€å§‹ã€‚ å®ç° MyLinkedList ç±»ï¼š MyLinkedList() åˆå§‹åŒ– MyLinkedList å¯¹è±¡ã€‚ int get(int index) è·å–é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœä¸‹æ ‡æ— æ•ˆï¼Œåˆ™è¿”å› -1 ã€‚ void addAtHead(int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰ã€‚åœ¨æ’å…¥å®Œæˆåï¼Œæ–°èŠ‚ç‚¹ä¼šæˆä¸ºé“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ void addAtTail(int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹è¿½åŠ åˆ°é“¾è¡¨ä¸­ä½œä¸ºé“¾è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚ void addAtIndex(int index, int val) å°†ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹ä¹‹å‰ã€‚å¦‚æœ index ç­‰äºé“¾è¡¨çš„é•¿åº¦ï¼Œé‚£ä¹ˆè¯¥èŠ‚ç‚¹ä¼šè¢«è¿½åŠ åˆ°é“¾è¡¨çš„æœ«å°¾ã€‚å¦‚æœ index æ¯”é•¿åº¦æ›´å¤§ï¼Œè¯¥èŠ‚ç‚¹å°† ä¸ä¼šæ’å…¥ åˆ°é“¾è¡¨ä¸­ã€‚ void deleteAtIndex(int index) å¦‚æœä¸‹æ ‡æœ‰æ•ˆï¼Œåˆ™åˆ é™¤é“¾è¡¨ä¸­ä¸‹æ ‡ä¸º index çš„èŠ‚ç‚¹ã€‚ æ€è·¯ï¼šä½¿ç”¨è™šæ‹Ÿå¤´æŒ‡é’ˆï¼å¢åŠ /åˆ é™¤æ–°èŠ‚ç‚¹çš„æ—¶å€™è¦ä¿è¯indexä¸ºcur.nextï¼Œè¿™æ ·æ‰èƒ½è¿›è¡Œæ“ä½œã€‚å¦å¤–å¢åŠ çš„æ—¶å€™éœ€è¦å…ˆè®©newnode.next=cur.nextï¼Œå†è®©cur.next=newnodeï¼Œé¡ºåºä¸èƒ½é”™ï¼ï¼ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class MyLinkedList { class ListNode { int val; ListNode next; ListNode(int val) { this.val=val; } } //sizeå­˜å‚¨é“¾è¡¨å…ƒç´ çš„ä¸ªæ•° private int size; //æ³¨æ„è¿™é‡Œè®°å½•çš„æ˜¯è™šæ‹Ÿå¤´ç»“ç‚¹ private ListNode head; public MyLinkedList() { this.size = 0; this.head = new ListNode(0); } public int get(int index) { if(index&lt;0 || index&gt;=size){ return -1; } ListNode cur = head.next; while(index&gt;0){ cur = cur.next; index--; } return cur.val; } public void addAtHead(int val) { ListNode newnode = new ListNode(val); newnode.next = head.next; head.next = newnode; size++; } public void addAtTail(int val) { ListNode newnode = new ListNode(val); ListNode cur = head; while(cur.next!=null){ cur = cur.next; } newnode.next = null; cur.next = newnode; size++; } public void addAtIndex(int index, int val) { if(index&lt;0 || index&gt;size){ return; } ListNode newnode = new ListNode(val); ListNode cur = head; while(index&gt;0){ cur = cur.next; index--; } newnode.next = cur.next; cur.next = newnode; size++; } public void deleteAtIndex(int index) { if(index&lt;0 || index&gt;=size){ return; } ListNode cur = head; while(index&gt;0){ cur = cur.next; index--; } cur.next = cur.next.next; size--; }} 206.åè½¬é“¾è¡¨ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨ã€‚ æ€è·¯ï¼šåŒæŒ‡é’ˆæ³•ï¼Œè®¾ç½®curå’Œcurå‰é¢çš„æŒ‡é’ˆpreï¼Œåˆ†åˆ«åˆå§‹åŒ–ä¸ºå¤´èŠ‚ç‚¹å’Œnullï¼ˆå› ä¸ºåè½¬åç°åœ¨çš„å¤´èŠ‚ç‚¹ä¸ºæœ€åä¸€ä¸ªï¼Œè¦æŒ‡å‘nullï¼‰ï¼Œwhileå¾ªç¯åœ¨curæŒ‡å‘nullç»“æŸã€‚åœ¨å¾ªç¯ä¸­å…ˆä½¿ç”¨tempå­˜ä¸€ä¸‹cur.nextï¼Œä»¥å…åç»­æ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªï¼Œç„¶åè°ƒè½¬æŒ‡é’ˆæ–¹å‘ï¼ŒæŠŠcur.nextå˜ä¸ºpreï¼Œä¹‹åå…ˆæŠŠpreå˜ä¸ºcurï¼Œå†æŠŠcurå˜ä¸ºtempï¼ˆä¹‹å‰å­˜çš„cur.nextï¼‰ã€‚åäº†çš„è¯å°±æ‰¾ä¸åˆ°èµ‹å€¼ç»™preçš„curäº†ï¼ 1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode reverseList(ListNode head) { ListNode cur = head; ListNode pre = null; while(cur!= null){ ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; } return pre; }} 24.ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œä¸¤ä¸¤äº¤æ¢å…¶ä¸­ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›äº¤æ¢åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ä½ å¿…é¡»åœ¨ä¸ä¿®æ”¹èŠ‚ç‚¹å†…éƒ¨çš„å€¼çš„æƒ…å†µä¸‹å®Œæˆæœ¬é¢˜ï¼ˆå³ï¼Œåªèƒ½è¿›è¡ŒèŠ‚ç‚¹äº¤æ¢ï¼‰ã€‚ æ€è·¯ï¼šä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œé‡ç‚¹æ˜¯è¦äº¤æ¢ä¸¤ä¸ªèŠ‚ç‚¹1ï¼Œ2çš„è¯ï¼Œcurè¦æŒ‡å‘1å‰é¢çš„ä½ç½®ï¼æ¢çš„æ—¶å€™æ³¨æ„ä¿å­˜tempã€‚åŒæ—¶whileçš„ç»ˆæ­¢æ¡ä»¶ä¸€å®šè¦å†™å¯¹ï¼Œæ³¨æ„æ˜¯&amp;&amp;ï¼Œå¦‚æœå†™ï½œï½œçš„è¯ä¼šæœ‰ç©ºæŒ‡é’ˆçš„æŠ¥é”™ã€‚ 12345678910111213141516class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; ListNode cur = dummy; while(cur.next!=null &amp;&amp; cur.next.next!=null){ ListNode temp = cur.next;//èŠ‚ç‚¹1 ListNode temp1 = cur.next.next.next;//èŠ‚ç‚¹3 cur.next = cur.next.next;//å¤´èŠ‚ç‚¹æŒ‡å‘èŠ‚ç‚¹2 cur.next.next = temp;//èŠ‚ç‚¹2æŒ‡å‘èŠ‚ç‚¹1 temp.next = temp1; cur = cur.next.next; } return dummy.next; }} 19.åˆ é™¤é“¾è¡¨å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹ç»™ä½ ä¸€ä¸ªé“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”è¿”å›é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚ æ€è·¯ï¼šä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹ï¼Œå¿«æ…¢æŒ‡é’ˆã€‚å¾ˆå·§å¦™çš„æ€è·¯ï¼šå…ˆè®©fastèµ°næ­¥ï¼Œç„¶åè®©fastå’Œslowä¸€èµ·èµ°ï¼Œç›´åˆ°fastä¸ºnullçš„æ—¶å€™slowæŒ‡å‘çš„å°±æ˜¯å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹ï¼ï¼Œä½†æ˜¯å› ä¸ºè¦åˆ é™¤å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥slowå¿…é¡»æŒ‡å‘å€’æ•°ç¬¬nä¸ªèŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¸€å¼€å§‹è®©fastèµ°n+1æ­¥å³å¯ã€‚ 123456789101112131415161718192021class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; //è®©slowåœ¨è¦åˆ é™¤èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹çš„ä½ç½®ï¼ n++; //æ³¨æ„æ˜¯fast!=null,ä¸æ˜¯fast.next while(n&gt;0 &amp;&amp; fast!=null){ fast = fast.next; n--; } while(fast!=null){ fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return dummy.next; }} 142.ç¯å½¢é“¾è¡¨IIç»™å®šä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¿”å›é“¾è¡¨å¼€å§‹å…¥ç¯çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ å¦‚æœé“¾è¡¨æ— ç¯ï¼Œåˆ™è¿”å› nullã€‚ å¦‚æœé“¾è¡¨ä¸­æœ‰æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡è¿ç»­è·Ÿè¸ª next æŒ‡é’ˆå†æ¬¡åˆ°è¾¾ï¼Œåˆ™é“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œè¯„æµ‹ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨æ•´æ•° pos æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚å¦‚æœ pos æ˜¯ -1ï¼Œåˆ™åœ¨è¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚æ³¨æ„ï¼špos ä¸ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’ï¼Œä»…ä»…æ˜¯ä¸ºäº†æ ‡è¯†é“¾è¡¨çš„å®é™…æƒ…å†µã€‚ä¸å…è®¸ä¿®æ”¹ é“¾è¡¨ã€‚ æ€è·¯ï¼šæ¶‰åŠåˆ°æ•°å­¦æ¨å¯¼ï¼Œæœ€åçš„ç»“è®ºï¼šä»å¤´ç»“ç‚¹å‡ºå‘ä¸€ä¸ªæŒ‡é’ˆï¼Œä»ç›¸é‡èŠ‚ç‚¹ ä¹Ÿå‡ºå‘ä¸€ä¸ªæŒ‡é’ˆï¼Œè¿™ä¸¤ä¸ªæŒ‡é’ˆæ¯æ¬¡åªèµ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ é‚£ä¹ˆå½“è¿™ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡çš„æ—¶å€™å°±æ˜¯ ç¯å½¢å…¥å£çš„èŠ‚ç‚¹ 1234567891011121314151617181920public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast = head; ListNode slow = head; while(fast!=null &amp;&amp; fast.next!=null){ fast = fast.next.next; slow = slow.next; if(fast == slow){ ListNode index1 = fast; ListNode index2 = head; while(index1!=index2){ index1 = index1.next; index2 = index2.next; } return index1; } } return null; }} 160.ç›¸äº¤é“¾è¡¨ç»™ä½ ä¸¤ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ headA å’Œ headB ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›ä¸¤ä¸ªå•é“¾è¡¨ç›¸äº¤çš„èµ·å§‹èŠ‚ç‚¹ã€‚å¦‚æœä¸¤ä¸ªé“¾è¡¨ä¸å­˜åœ¨ç›¸äº¤èŠ‚ç‚¹ï¼Œè¿”å› null ã€‚ æ€è·¯ï¼šç›¸äº¤å¤„çš„æŒ‡é’ˆæ˜¯ç›¸ç­‰çš„ï¼Œå¯ä»¥æŠŠé•¿é“¾è¡¨æŒ‡é’ˆcurAå’ŒçŸ­é“¾è¡¨æŒ‡é’ˆcurBçš„å¤´éƒ¨å¯¹é½ï¼Œç„¶åä¸¤ä¸ªæŒ‡é’ˆä¸€èµ·ç§»åŠ¨å¦‚æœä¸¤ä¸ªæŒ‡é’ˆç›¸ç­‰äº†å°±è¯´æ˜è¿™ä¸ªç‚¹ä¸ºç›¸äº¤çš„ç‚¹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode curA = headA; ListNode curB = headB; int lenA = 0; int lenB = 0; while(curA!=null){ curA = curA.next; lenA++; } while(curB!=null){ curB = curB.next; lenB++; } curA = headA; curB = headB; if(lenB &gt;lenA){ ListNode temp = curA; curA = curB; curB = temp; int templen = lenA; lenA = lenB; lenB = templen; } int gap = lenA - lenB; while(gap&gt;0){ curA = curA.next; gap--; } while(curA!=null){ if(curA == curB){ return curA; } curA = curA.next; curB = curB.next; } return null; }} 234.å›æ–‡é“¾è¡¨ç»™ä½ ä¸€ä¸ªå•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ head ï¼Œè¯·ä½ åˆ¤æ–­è¯¥é“¾è¡¨æ˜¯å¦ä¸ºå›æ–‡é“¾è¡¨ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚ æ€è·¯ï¼šä½¿ç”¨ä¸€ä¸ªæ•°ç»„æŠŠè¿™ä¸ªé“¾è¡¨é‡Œçš„æ•°å­—å­˜è¿›æ¥ï¼Œç„¶åforå¾ªç¯åˆ¤æ–­å¤´å°¾æ˜¯å¦ç›¸ç­‰ï¼Œæœ‰ä¸ç›¸ç­‰æ—¶åˆ™ä¸æ˜¯å›æ–‡ã€‚ 12345678910111213141516171819202122class Solution { public boolean isPalindrome(ListNode head) { ListNode cur = head; int len = 0; while(cur!=null){ cur = cur.next; len++; } cur = head; int[] seq = new int[len]; for(int i=0;i&lt;len;i++){ seq[i]=cur.val; cur = cur.next; } for(int a=0,b=len-1;b&gt;a;a++,b--){ if(seq[a]!=seq[b]){ return false; } } return true; }} 21.åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨å°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ å‡åº é“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„ã€‚ æ€è·¯ï¼šä½¿ç”¨è™šæ‹Ÿå¤´èŠ‚ç‚¹å’ŒcuræŒ‡é’ˆæ¥æ„å»ºæ–°é“¾è¡¨ï¼Œæ³¨æ„è¦å¤„ç†å‰©ä½™èŠ‚ç‚¹ 1234567891011121314151617181920212223242526class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode cur1 = list1; ListNode cur2 = list2; ListNode dummy = new ListNode(); ListNode cur = dummy; while(cur1!=null&amp;&amp;cur2!=null){ if(cur2.val&lt;=cur1.val){ cur.next = cur2; cur2 = cur2.next; } else{ cur.next = cur1; cur1 = cur1.next; } cur = cur.next; } if(cur1!=null){ cur.next = cur1; } if(cur2!=null){ cur.next = cur2; } return dummy.next; }}","link":"/2026/02/09/leetcode-%E9%93%BE%E8%A1%A8/"},{"title":"leetcode_æ•°ç»„","text":"ä»£ç éšæƒ³å½•â€”â€”æ•°ç»„704. äºŒåˆ†æŸ¥æ‰¾ç»™å®šä¸€ä¸ª n ä¸ªå…ƒç´ æœ‰åºçš„ï¼ˆå‡åºï¼‰æ•´å‹æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ target ï¼Œå†™ä¸€ä¸ªå‡½æ•°æœç´¢ nums ä¸­çš„ targetï¼Œå¦‚æœ target å­˜åœ¨è¿”å›ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› -1ã€‚ ä½ å¿…é¡»ç¼–å†™ä¸€ä¸ªå…·æœ‰ O(log n) æ—¶é—´å¤æ‚åº¦çš„ç®—æ³•ã€‚ æ³¨æ„rightè¦-1ï¼ 12345678910111213141516171819class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length -1;//å› ä¸ºå·¦å³æ˜¯é—­åŒºé—´æ‰€ä»¥æ³¨æ„è¦-1ï¼ï¼ while(left &lt;= right){//å·¦é—­å³é—­ int middle = left+(right-left)/2; if(target &lt; nums[middle]){ right = middle -1; } else if (target &gt; nums[middle]){ left = middle + 1; } else{ return middle; } } return -1; }} 35.æœç´¢æ’å…¥ä½ç½®ç»™å®šä¸€ä¸ªæ’åºæ•°ç»„å’Œä¸€ä¸ªç›®æ ‡å€¼ï¼Œåœ¨æ•°ç»„ä¸­æ‰¾åˆ°ç›®æ ‡å€¼ï¼Œå¹¶è¿”å›å…¶ç´¢å¼•ã€‚å¦‚æœç›®æ ‡å€¼ä¸å­˜åœ¨äºæ•°ç»„ä¸­ï¼Œè¿”å›å®ƒå°†ä¼šè¢«æŒ‰é¡ºåºæ’å…¥çš„ä½ç½®ã€‚æ—¶é—´å¤æ‚åº¦O(log n) ç¤ºä¾‹ 1: 12è¾“å…¥: nums = [1,3,5,6], target = 5è¾“å‡º: 2 æˆ‘çš„æ€è·¯ï¼šæ­£å¸¸ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ï¼Œä¸ç»å…¸é¢˜ä¸åŒçš„æ˜¯ç›®æ ‡å€¼ä¸å­˜åœ¨æ•°ç»„ä¸­çš„æƒ…å†µä¸‹è¿”å›leftå³å¯ï¼ˆå› ä¸ºleftæ˜¯ç¬¬ä¸€ä¸ª â‰¥ target çš„ä½ç½®ï¼Œå³æ’å…¥ç‚¹ï¼‰ 12345678910111213141516171819class Solution { public int searchInsert(int[] nums, int target) { int left = 0; int right = nums.length - 1; while(left&lt;=right){ int middle = left+(right-left)/2; if (target &lt; nums[middle]){ right = middle - 1; } else if (target &gt; nums[middle]){ left = middle + 1; } else{ return middle; } } return left; }} 74.æœç´¢äºŒç»´çŸ©é˜µç»™ä½ ä¸€ä¸ªæ»¡è¶³ä¸‹è¿°ä¸¤æ¡å±æ€§çš„ m x n æ•´æ•°çŸ©é˜µï¼š æ¯è¡Œä¸­çš„æ•´æ•°ä»å·¦åˆ°å³æŒ‰éä¸¥æ ¼é€’å¢é¡ºåºæ’åˆ—ã€‚ æ¯è¡Œçš„ç¬¬ä¸€ä¸ªæ•´æ•°å¤§äºå‰ä¸€è¡Œçš„æœ€åä¸€ä¸ªæ•´æ•°ã€‚ ç»™ä½ ä¸€ä¸ªæ•´æ•° target ï¼Œå¦‚æœ target åœ¨çŸ©é˜µä¸­ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚ æˆ‘çš„æ€è·¯ï¼šäºŒç»´æ•°ç»„è¦åŠ ä¸Šå¯¹æ¯è¡Œçš„forå¾ªç¯ã€‚ä¸”è¦æ³¨æ„leftå’Œrightå†™åœ¨å¾ªç¯å†…éƒ¨whileå‰é¢ï¼Œåœ¨æ¯æ¬¡æ–°çš„forå¾ªç¯å¼€å§‹é‡æ–°å¯¹leftå’Œrightè¿›è¡Œåˆå§‹åŒ–ï¼ 123456789101112131415161718192021class Solution { public boolean searchMatrix(int[][] matrix, int target) { for (int col=0;col&lt;matrix.length;col++){ int left = 0; int right = matrix[0].length -1; while (left &lt;= right){ int middle = left+(right - left)/2; if(target &lt; matrix[col][middle]){ right = middle - 1; } else if (target &gt; matrix[col][middle]){ left = middle + 1; } else{ return true; } } } return false; }} 34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®ç»™ä½ ä¸€ä¸ªæŒ‰ç…§éé€’å‡é¡ºåºæ’åˆ—çš„æ•´æ•°æ•°ç»„ numsï¼Œå’Œä¸€ä¸ªç›®æ ‡å€¼ targetã€‚è¯·ä½ æ‰¾å‡ºç»™å®šç›®æ ‡å€¼åœ¨æ•°ç»„ä¸­çš„å¼€å§‹ä½ç½®å’Œç»“æŸä½ç½®ã€‚ å¦‚æœæ•°ç»„ä¸­ä¸å­˜åœ¨ç›®æ ‡å€¼ targetï¼Œè¿”å› [-1, -1]ã€‚ ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º O(log n) çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚ ç¤ºä¾‹ 1ï¼š 12è¾“å…¥ï¼šnums = [5,7,7,8,8,10], target = 8è¾“å‡ºï¼š[3,4] æˆ‘çš„æ€è·¯ï¼šè¦å­¦ä¼šä½¿ç”¨å‡½æ•°æ¥å†™ï¼Œèƒ½æ›´æœ‰æ¡ç†ã€‚è¿™é“é¢˜è¦ç”¨ä¸¤ä¸ªäºŒåˆ†æŸ¥æ‰¾ï¼Œä¸ç»å…¸é¢˜ç›¸æ¯”ï¼Œä¸åŒçš„åœ°æ–¹åœ¨äºäºŒåˆ†æŸ¥æ‰¾éœ€è¦ä¿®æ”¹ä¸ºï¼šå½“middleç´¢å¼•å¯¹åº”çš„æ•°ç­‰äºtargetçš„æ—¶å€™ä»ç„¶éœ€è¦ç»§ç»­æŸ¥æ‰¾ï¼Œå› æ­¤ä»£ç ä¸­elseé‡Œè¦è®°å½•å€™é€‰å¹¶ç»§ç»­å‘å·¦/å³æœç´¢ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution { public int[] searchRange(int[] nums, int target) { int left = findFirst(nums, target); if (left == -1) { return new int[]{-1, -1}; } int right = findLast(nums, target); return new int[]{left, right}; } // æ‰¾ç¬¬ä¸€ä¸ªç­‰äº target çš„ç´¢å¼• private int findFirst(int[] nums, int target) { int left = 0, right = nums.length - 1; int result = -1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { result = mid; // è®°å½•å€™é€‰ right = mid - 1; // ç»§ç»­å‘å·¦æœç´¢ } else if (nums[mid] &lt; target) { left = mid + 1; } else { right = mid - 1; } } return result; } // æ‰¾æœ€åä¸€ä¸ªç­‰äº target çš„ç´¢å¼• private int findLast(int[] nums, int target) { int left = 0, right = nums.length - 1; int result = -1; while (left &lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) { result = mid; // è®°å½•å€™é€‰ left = mid + 1; // ç»§ç»­å‘å³æœç´¢ } else if (nums[mid] &lt; target) { left = mid + 1; } else { right = mid - 1; } } return result; }} 33.æœç´¢æ—‹è½¬æ’åºæ•°ç»„æ•´æ•°æ•°ç»„ nums æŒ‰å‡åºæ’åˆ—ï¼Œæ•°ç»„ä¸­çš„å€¼ äº’ä¸ç›¸åŒ ã€‚ åœ¨ä¼ é€’ç»™å‡½æ•°ä¹‹å‰ï¼Œnums åœ¨é¢„å…ˆæœªçŸ¥çš„æŸä¸ªä¸‹æ ‡ kï¼ˆ0 &lt;= k &lt; nums.lengthï¼‰ä¸Šè¿›è¡Œäº† å‘å·¦æ—‹è½¬ï¼Œä½¿æ•°ç»„å˜ä¸º [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]ï¼ˆä¸‹æ ‡ ä» 0 å¼€å§‹ è®¡æ•°ï¼‰ã€‚ä¾‹å¦‚ï¼Œ [0,1,2,4,5,6,7] ä¸‹æ ‡ 3 ä¸Šå‘å·¦æ—‹è½¬åå¯èƒ½å˜ä¸º [4,5,6,7,0,1,2] ã€‚ ç»™ä½  æ—‹è½¬å çš„æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° target ï¼Œå¦‚æœ nums ä¸­å­˜åœ¨è¿™ä¸ªç›®æ ‡å€¼ target ï¼Œåˆ™è¿”å›å®ƒçš„ä¸‹æ ‡ï¼Œå¦åˆ™è¿”å› -1 ã€‚ ä½ å¿…é¡»è®¾è®¡ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º O(log n) çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚ ç¤ºä¾‹ 1ï¼š 12è¾“å…¥ï¼šnums = [4,5,6,7,0,1,2], target = 0è¾“å‡ºï¼š4 æˆ‘çš„æ€è·¯ï¼š æ¯æ¬¡å°†æ•°ç»„ä¸€åˆ†ä¸ºäºŒï¼šå–ä¸­ç‚¹ midï¼Œé‚£ä¹ˆ [left, mid] å’Œ [mid+1, right] ä¸­è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯æœ‰åºçš„ï¼ˆå› ä¸ºåŸæ•°ç»„æ˜¯å‡åºä¸”æ— é‡å¤ï¼‰ã€‚ åˆ¤æ–­å“ªä¸€åŠæ˜¯æœ‰åºçš„ï¼š å¦‚æœ nums[left] &lt;= nums[mid] â†’ å·¦åŠéƒ¨åˆ†æœ‰åº å¦åˆ™ â†’ å³åŠéƒ¨åˆ†æœ‰åº æ£€æŸ¥ target æ˜¯å¦è½åœ¨æœ‰åºçš„é‚£ä¸€åŠï¼š å¦‚æœåœ¨ï¼Œå°±åœ¨è¯¥åŒºé—´åšæ ‡å‡†äºŒåˆ†æŸ¥æ‰¾ï¼ˆç¼©å°èŒƒå›´ï¼‰ å¦‚æœä¸åœ¨ï¼Œå°±å»å¦ä¸€åŠï¼ˆæ— åºéƒ¨åˆ†ï¼‰ç»§ç»­é€’å½’/è¿­ä»£ 1234567891011121314151617181920212223242526272829class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length -1; while (left &lt;= right){ int middle = left+(right-left)/2;//åˆ«å¿˜äº†å†™middleæ›´æ–°ï¼ï¼ if(nums[middle] == target){ return middle; } if(nums[left]&lt;=nums[middle]){ if(target&lt;nums[middle] &amp;&amp; target&gt;=nums[left]){ right = middle - 1; } else{ left = middle + 1; } } if(nums[right]&gt;=nums[middle]){ if(target&gt;nums[middle] &amp;&amp; target&lt;=nums[right]){ left = middle + 1; } else{ right = middle - 1; } } } return -1; }} 153.å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼å·²çŸ¥ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ï¼Œé¢„å…ˆæŒ‰ç…§å‡åºæ’åˆ—ï¼Œç»ç”± 1 åˆ° n æ¬¡ æ—‹è½¬ åï¼Œå¾—åˆ°è¾“å…¥æ•°ç»„ã€‚ä¾‹å¦‚ï¼ŒåŸæ•°ç»„ nums = [0,1,2,4,5,6,7] åœ¨å˜åŒ–åå¯èƒ½å¾—åˆ°ï¼š è‹¥æ—‹è½¬ 4 æ¬¡ï¼Œåˆ™å¯ä»¥å¾—åˆ° [4,5,6,7,0,1,2] è‹¥æ—‹è½¬ 7 æ¬¡ï¼Œåˆ™å¯ä»¥å¾—åˆ° [0,1,2,4,5,6,7] æ³¨æ„ï¼Œæ•°ç»„ [a[0], a[1], a[2], ..., a[n-1]] æ—‹è½¬ä¸€æ¬¡ çš„ç»“æœä¸ºæ•°ç»„ [a[n-1], a[0], a[1], a[2], ..., a[n-2]] ã€‚ ç»™ä½ ä¸€ä¸ªå…ƒç´ å€¼ äº’ä¸ç›¸åŒ çš„æ•°ç»„ nums ï¼Œå®ƒåŸæ¥æ˜¯ä¸€ä¸ªå‡åºæ’åˆ—çš„æ•°ç»„ï¼Œå¹¶æŒ‰ä¸Šè¿°æƒ…å½¢è¿›è¡Œäº†å¤šæ¬¡æ—‹è½¬ã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›æ•°ç»„ä¸­çš„ æœ€å°å…ƒç´  ã€‚ ä½ å¿…é¡»è®¾è®¡ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸º O(log n) çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜ã€‚ æˆ‘çš„æ€è·¯ï¼šåœ¨æ•´ä¸ª while å¾ªç¯è¿‡ç¨‹ä¸­ï¼Œæ•°ç»„çš„æœ€å°å€¼ never leaves the interval [left, right]ã€‚åªè¦è¿™ä¸ªä¸å˜é‡æˆç«‹ï¼Œé‚£ä¹ˆå½“åŒºé—´ç¼©å°åˆ°åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼ˆleft == rightï¼‰æ—¶ï¼Œé‚£ä¸ªå…ƒç´ å¿…ç„¶å°±æ˜¯æœ€å°å€¼ äºŒåˆ†æŸ¥æ‰¾çš„ä½œç”¨ç›¸å½“äºæ˜¯æ¯æ¬¡éƒ½æ’é™¤ä¸€åŠåŒºé—´ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªleft==rightçš„åœ°æ–¹ã€‚æ‰€ä»¥whileé‚£é‡Œä¸èƒ½å†™ç­‰äºå·ï¼ 12345678910111213141516class Solution { public int findMin(int[] nums) { int left = 0; int right = nums.length - 1; while(left &lt; right){ int middle = left+(right-left)/2; if(nums[middle]&lt;nums[right]){ right = middle; } else if(nums[middle]&gt;nums[right]){ left = middle +1; } } return nums[right];}} 27.ç§»é™¤å…ƒç´ ç»™ä½ ä¸€ä¸ªæ•°ç»„ nums å’Œä¸€ä¸ªå€¼ valï¼Œä½ éœ€è¦ åŸåœ° ç§»é™¤æ‰€æœ‰æ•°å€¼ç­‰äº val çš„å…ƒç´ ã€‚å…ƒç´ çš„é¡ºåºå¯èƒ½å‘ç”Ÿæ”¹å˜ã€‚ç„¶åè¿”å› nums ä¸­ä¸ val ä¸åŒçš„å…ƒç´ çš„æ•°é‡ã€‚ å‡è®¾ nums ä¸­ä¸ç­‰äº val çš„å…ƒç´ æ•°é‡ä¸º kï¼Œè¦é€šè¿‡æ­¤é¢˜ï¼Œæ‚¨éœ€è¦æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š æ›´æ”¹ nums æ•°ç»„ï¼Œä½¿ nums çš„å‰ k ä¸ªå…ƒç´ åŒ…å«ä¸ç­‰äº val çš„å…ƒç´ ã€‚nums çš„å…¶ä½™å…ƒç´ å’Œ nums çš„å¤§å°å¹¶ä¸é‡è¦ã€‚ è¿”å› kã€‚ åŒæŒ‡é’ˆæ³•æ€è·¯ï¼šå¿«æŒ‡é’ˆå¯»æ‰¾æ–°æ•°ç»„ä¸­çš„å€¼ï¼Œæ…¢æŒ‡é’ˆæŒ‡å‘æ›´æ–° æ–°æ•°ç»„ä¸‹æ ‡çš„ä½ç½® 123456789101112class Solution { public int removeElement(int[] nums, int val) { int slow = 0; for(int fast=0;fast&lt;nums.length;fast++){ if(nums[fast] != val){ nums[slow] = nums[fast]; slow++; } } return slow; }} 283.ç§»åŠ¨é›¶ç»™å®šä¸€ä¸ªæ•°ç»„ numsï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°å°†æ‰€æœ‰ 0 ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ï¼ŒåŒæ—¶ä¿æŒéé›¶å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚ è¯·æ³¨æ„ ï¼Œå¿…é¡»åœ¨ä¸å¤åˆ¶æ•°ç»„çš„æƒ…å†µä¸‹åŸåœ°å¯¹æ•°ç»„è¿›è¡Œæ“ä½œã€‚ ç¤ºä¾‹ 1: 12è¾“å…¥: nums = [0,1,0,3,12]è¾“å‡º: [1,3,12,0,0] æˆ‘çš„æ€è·¯ï¼šä½¿ç”¨åŒæŒ‡é’ˆæ³•æŠŠä¸ç­‰äº0çš„å…ƒç´ å»ºç«‹ä¸ºæ–°æ•°ç»„ç„¶åå…¶ä½™å…ƒç´ èµ‹å€¼ä¸º0å³å¯ 1234567891011121314class Solution { public void moveZeroes(int[] nums) { int slow = 0; for(int fast=0;fast&lt;nums.length;fast++){ if(nums[fast]!=0){ nums[slow]=nums[fast]; slow++; } } for(int a=slow;a&lt;nums.length;a++){ nums[a]=0; } }} 977.æœ‰åºæ•°ç»„çš„å¹³æ–¹ç»™ä½ ä¸€ä¸ªæŒ‰ éé€’å‡é¡ºåº æ’åºçš„æ•´æ•°æ•°ç»„ numsï¼Œè¿”å› æ¯ä¸ªæ•°å­—çš„å¹³æ–¹ ç»„æˆçš„æ–°æ•°ç»„ï¼Œè¦æ±‚ä¹ŸæŒ‰ éé€’å‡é¡ºåº æ’åºã€‚ ç¤ºä¾‹ 1ï¼š 1234è¾“å…¥ï¼šnums = [-4,-1,0,3,10]è¾“å‡ºï¼š[0,1,9,16,100]è§£é‡Šï¼šå¹³æ–¹åï¼Œæ•°ç»„å˜ä¸º [16,1,0,9,100]æ’åºåï¼Œæ•°ç»„å˜ä¸º [0,1,9,16,100] æ€è·¯ï¼šä½¿ç”¨å·¦å³åŒæŒ‡é’ˆã€‚å·¦è¾¹çš„åœ¨æœ€å‰é¢å³è¾¹çš„åœ¨æœ€åé¢ï¼Œåˆå§‹åŒ–ä¸€ä¸ªresultæ•°ç»„ç”¨æ¥å­˜å¹³æ–¹åçš„ç»“æœï¼Œåˆå§‹åŒ–ä¸€ä¸ªkä»æ•°ç»„çš„æœ€åè¿›è¡Œç´¢å¼•å­˜å‚¨ã€‚æ¯æ¬¡æ¯”è¾ƒå·¦è¾¹æŒ‡é’ˆå’Œå³è¾¹æŒ‡é’ˆæ•°å­—å¹³æ–¹çš„å¤§å°ï¼ŒæŠŠå¤§çš„å­˜è¿›resultçš„kä¸­ï¼Œç„¶åæ›´æ–°kå’ŒæŒ‡é’ˆã€‚whileå·¦æŒ‡é’ˆ&lt;=å³æŒ‡é’ˆ 123456789101112131415161718192021class Solution { public int[] sortedSquares(int[] nums) { int[] result =new int[nums.length]; int k = nums.length -1; int left = 0; int right = nums.length -1; while(left&lt;=right){ if(nums[left]*nums[left]&gt;nums[right]*nums[right]){ result[k]=nums[left]*nums[left]; k--; left++; } else{ result[k]=nums[right]*nums[right]; k--; right--; } } return result; }} 209.é•¿åº¦æœ€å°çš„å­æ•°ç»„ï¼ˆæ»‘åŠ¨çª—å£ï¼‰ç»™å®šä¸€ä¸ªå«æœ‰ n ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° target ã€‚ æ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶æ€»å’Œå¤§äºç­‰äº target çš„é•¿åº¦æœ€å°çš„ å­æ•°ç»„ [numsl, numsl+1, ..., numsr-1, numsr] ï¼Œå¹¶è¿”å›å…¶é•¿åº¦**ã€‚**å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› 0 ã€‚ ç¤ºä¾‹ 1ï¼š 123è¾“å…¥ï¼štarget = 7, nums = [2,3,1,2,4,3]è¾“å‡ºï¼š2è§£é‡Šï¼šå­æ•°ç»„ [4,3] æ˜¯è¯¥æ¡ä»¶ä¸‹çš„é•¿åº¦æœ€å°çš„å­æ•°ç»„ã€‚ æ€è·¯ï¼šä½¿ç”¨æ»‘åŠ¨çª—å£ã€‚åŒæŒ‡é’ˆleftå’Œrightï¼Œrightåœ¨forå¾ªç¯ä¸­å¢åŠ æ¥è¿›è¡Œçª—å£å³è¾¹ç•Œçš„æ‰©å¤§ï¼Œå½“çª—å£å†…çš„æ€»å’Œå¤§äºç­‰äºtargetçš„æ—¶å€™è¦æŒªåŠ¨å·¦è¾¹ç•Œæ¥æ‰¾æœ€å°çš„çª—å£å¤§å°ã€‚ä¸€å¼€å§‹çš„resultï¼ˆçª—å£å¤§å°ï¼‰å¯ä»¥è®¾ç½®ä¸ºInteger.MAX_VALUEï¼ŒåŒæ—¶è¿˜éœ€è¦ç”¨åˆ°æ¯”è¾ƒæ¯æ¬¡çš„çª—å£é•¿åº¦å’Œresulté•¿åº¦çš„å¤§å°ï¼Œè¦ä½¿ç”¨åˆ°Math.min 12345678910111213141516class Solution { public int minSubArrayLen(int target, int[] nums) { int sum = 0; int left = 0; int result = Integer.MAX_VALUE; for (int right=0;right&lt;nums.length;right++){ sum += nums[right]; while(sum&gt;=target){ result = Math.min(result,right-left+1); sum -= nums[left]; left++; } } return result==Integer.MAX_VALUE? 0: result; }} 59.èºæ—‹çŸ©é˜µç»™ä½ ä¸€ä¸ªæ­£æ•´æ•° n ï¼Œç”Ÿæˆä¸€ä¸ªåŒ…å« 1 åˆ° n^2 æ‰€æœ‰å…ƒç´ ï¼Œä¸”å…ƒç´ æŒ‰é¡ºæ—¶é’ˆé¡ºåºèºæ—‹æ’åˆ—çš„ n x n æ­£æ–¹å½¢çŸ©é˜µ matrix ã€‚ æ€è·¯ï¼šæ¨¡æ‹Ÿé¡ºæ—¶é’ˆç”»çŸ©é˜µçš„è¿‡ç¨‹: å¡«å……ä¸Šè¡Œä»å·¦åˆ°å³ å¡«å……å³åˆ—ä»ä¸Šåˆ°ä¸‹ å¡«å……ä¸‹è¡Œä»å³åˆ°å·¦ å¡«å……å·¦åˆ—ä»ä¸‹åˆ°ä¸Š ç”±å¤–å‘å†…ä¸€åœˆä¸€åœˆè¿™ä¹ˆç”»ä¸‹å»ã€‚æ¯ç”»ä¸€æ¡è¾¹éƒ½è¦åšæŒä¸€è‡´çš„å·¦é—­å³å¼€çš„åŸåˆ™ 123456789101112131415161718192021222324252627282930313233class Solution { public int[][] generateMatrix(int n) { int startx = 0; int starty = 0; int offset = 1; int count = 1; int loop = 1; int i,j; int[][] nums = new int[n][n]; while(loop &lt;= n/2){ for (j=starty;j&lt;n-offset;j++){ nums[startx][j] = count++; } for(i=startx;i&lt;n-offset;i++){ nums[i][j] = count++; } for(;j&gt;starty;j--){ nums[i][j] = count++; } for(;i&gt;startx;i--){ nums[i][j] = count++; } startx++; starty++; offset++; loop++; } if(n % 2 == 1){ nums[startx][starty]=n*n; } return nums; }} 54.èºæ—‹çŸ©é˜µç»™ä½ ä¸€ä¸ª m è¡Œ n åˆ—çš„çŸ©é˜µ matrix ï¼Œè¯·æŒ‰ç…§ é¡ºæ—¶é’ˆèºæ—‹é¡ºåº ï¼Œè¿”å›çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { int m = matrix.length; int n = matrix[0].length; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int offset = 1; int startx = 0; int starty = 0; int total = m * n; int i, j; while (result.size() &lt; total) { i = startx; j = starty; boolean added = false; // å‘å³ for (; j &lt; n - offset &amp;&amp; result.size() &lt; total; j++) { result.add(matrix[i][j]); added = true; } // å‘ä¸‹ for (; i &lt; m - offset &amp;&amp; result.size() &lt; total; i++) { result.add(matrix[i][j]); added = true; } // å‘å·¦ for (; j &gt; starty &amp;&amp; result.size() &lt; total; j--) { result.add(matrix[i][j]); added = true; } // å‘ä¸Š for (; i &gt; startx &amp;&amp; result.size() &lt; total; i--) { result.add(matrix[i][j]); added = true; } // å¦‚æœè¿™ä¸€åœˆä»€ä¹ˆéƒ½æ²¡åŠ ï¼Œè¯´æ˜åªå‰©ä¸­å¿ƒç‚¹ if (!added &amp;&amp; result.size() &lt; total) { result.add(matrix[startx][starty]); } startx++; starty++; offset++; } return result; }}","link":"/2026/02/09/leetcode-%E6%95%B0%E7%BB%84/"},{"title":"ã€JAVAå­¦ä¹ ã€‘ç¬¬ä¸€å¤©","text":"ğŸ’¡ å­¦ä¹ ç›®æ ‡ï¼šç”¨ä¸€å¥è¯è¯´æ˜æœ¬ç¯‡è¦æŒæ¡ä»€ä¹ˆã€‚ ğŸ§  æ ¸å¿ƒæ¦‚å¿µç®€è¦ä»‹ç»æœ¬ä¸»é¢˜çš„æ ¸å¿ƒæ€æƒ³ã€‚ä¾‹å¦‚ï¼š ä»€ä¹ˆæ˜¯æ³›å‹ï¼Ÿ ä¸ºä»€ä¹ˆéœ€è¦æ³›å‹ï¼Ÿï¼ˆç±»å‹å®‰å…¨ã€é¿å…å¼ºåˆ¶è½¬æ¢ï¼‰ æ³›å‹åœ¨ç¼–è¯‘æœŸ vs è¿è¡ŒæœŸçš„è¡Œä¸ºï¼ˆç±»å‹æ“¦é™¤ï¼‰ ğŸ” å…³é”®è¯­æ³•ä¸ç¤ºä¾‹åŸºæœ¬ç”¨æ³•// ç¤ºä¾‹ï¼šæ³›å‹ç±» public class Box&lt;T&gt; { private T value; public void set(T value) { this.value = value; } public T get() { return value; } } // ä½¿ç”¨ Box&lt;String&gt; stringBox = new Box&lt;&gt;(); stringBox.set(&quot;Hello&quot;);","link":"/2026/02/09/%E3%80%90JAVA%E5%AD%A6%E4%B9%A0%E3%80%91%E7%AC%AC%E4%B8%80%E5%A4%A9/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[]}